import os
import discord
import datetime
import asyncio
from discord.ui import Button, View
from discord.ext import commands
from dotenv import load_dotenv

# Charger les variables d'environnement
load_dotenv('token.env')

# Configuration du bot
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = commands.Bot(command_prefix='/', intents=intents)

# Configuration
spam_cooldown = commands.CooldownMapping.from_cooldown(
    3, 10, commands.BucketType.user)
user_warnings = {}
user_spam_count = {}
whitelist = set()
antiraid_enabled = False
log_channel = None
captcha_codes = {}
ticket_category_id = 1332456333391433739
staff_role_id = 1332456095393906752


def generate_captcha():
    """G√©n√®re un code captcha al√©atoire"""
    import random
    import string
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))


class TicketView(View):

    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Fermer le ticket",
                       style=discord.ButtonStyle.danger,
                       emoji="üîí")
    async def close_ticket(self, interaction: discord.Interaction,
                           button: discord.ui.Button):
        if interaction.channel.name.startswith("ticket-"):
            embed = discord.Embed(
                title="Confirmation de fermeture",
                description="√ätes-vous s√ªr de vouloir fermer ce ticket ?",
                color=discord.Color.red())
            await interaction.response.send_message(embed=embed,
                                                    ephemeral=True,
                                                    delete_after=60)

            try:
                await interaction.channel.send(
                    "üîí Ce ticket sera ferm√© dans 5 secondes...")
                await asyncio.sleep(5)
                await interaction.channel.delete()
                if log_channel:
                    await log_channel.send(
                        f"üé´ Ticket ferm√© par {interaction.user.mention}")
            except:
                await interaction.followup.send(
                    "Une erreur est survenue lors de la fermeture du ticket.",
                    ephemeral=True)


@bot.tree.command(name="verify",
                  description="V√©rifier votre compte avec le code captcha")
async def verify(interaction: discord.Interaction, code: str):
    if interaction.user.id not in captcha_codes:
        await interaction.response.send_message(
            "Vous n'avez pas de code captcha en attente.", ephemeral=True)
        return

    if captcha_codes[interaction.user.id] != code:
        await interaction.response.send_message(
            "Code incorrect. Veuillez r√©essayer.", ephemeral=True)
        return

    verified_role = discord.utils.get(interaction.guild.roles, name="V√©rifi√©")
    visitor_role = interaction.guild.get_role(1332456121511710790)
    unverified_role = discord.utils.get(interaction.guild.roles,
                                        name="Non v√©rifi√©")

    if not verified_role:
        verified_role = await interaction.guild.create_role(name="V√©rifi√©")

    await interaction.user.add_roles(verified_role, visitor_role)
    if unverified_role:
        await interaction.user.remove_roles(unverified_role)

    del captcha_codes[interaction.user.id]
    await interaction.response.send_message(
        "‚úÖ Vous avez √©t√© v√©rifi√© avec succ√®s!", ephemeral=True)


@bot.tree.command(name="ticket", description="Ouvrir un nouveau ticket")
async def ticket(interaction: discord.Interaction, sujet: str):
    # V√©rifier le nombre de tickets existants
    user_tickets = [
        channel for channel in interaction.guild.text_channels
        if channel.name.startswith(f"ticket-{interaction.user.name.lower()}")
    ]
    if len(user_tickets) >= 2:
        await interaction.response.send_message(
            "Vous avez d√©j√† atteint la limite de 2 tickets.", ephemeral=True)
        return

    support_category = interaction.guild.get_channel(ticket_category_id)
    if not support_category:
        await interaction.response.send_message(
            "La cat√©gorie de support n'existe pas.", ephemeral=True)
        return

    staff_role = interaction.guild.get_role(staff_role_id)
    overwrites = {
        interaction.guild.default_role:
        discord.PermissionOverwrite(read_messages=False),
        interaction.user:
        discord.PermissionOverwrite(read_messages=True, send_messages=True),
        staff_role:
        discord.PermissionOverwrite(read_messages=True, send_messages=True)
        if staff_role else None
    }

    ticket_channel = await interaction.guild.create_text_channel(
        name=f"ticket-{interaction.user.name.lower()}",
        category=support_category,
        overwrites=overwrites,
        topic=f"Ticket de {interaction.user.name} - {sujet}")

    embed = discord.Embed(
        title="üé´ Nouveau Ticket",
        description=
        f"Bienvenue {interaction.user.mention} !\n\nUn membre du staff vous assistera d√®s que possible.\nSujet: {sujet}",
        color=discord.Color.blue())

    view = TicketView()
    await ticket_channel.send(embed=embed, view=view)
    await interaction.response.send_message(
        f"Votre ticket a √©t√© cr√©√© : {ticket_channel.mention}", ephemeral=True)

    if log_channel:
        await log_channel.send(
            f"üé´ Nouveau ticket cr√©√© par {interaction.user.mention} - Sujet: {sujet}"
        )


@bot.tree.command(name="panel_ticket",
                  description="Afficher le panel de ticket")
@commands.has_permissions(administrator=True)
async def panel_ticket(interaction: discord.Interaction):
    embed = discord.Embed(
        title="üìÆ Centre d'Assistance",
        description="S√©lectionnez le type de ticket que vous souhaitez cr√©er :",
        color=discord.Color.blue())
    embed.set_footer(text="L'√©quipe vous r√©pondra dans les plus brefs d√©lais.")

    class TicketView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=None)

        @discord.ui.button(label="Question g√©n√©rale", style=discord.ButtonStyle.primary, emoji="‚ùì")
        async def question_button(self, button_interaction: discord.Interaction, button: discord.ui.Button):
            await ticket(button_interaction, "Question g√©n√©rale")

        @discord.ui.button(label="Signalement", style=discord.ButtonStyle.danger, emoji="üö®")
        async def report_button(self, button_interaction: discord.Interaction, button: discord.ui.Button):
            await ticket(button_interaction, "Signalement")

        @discord.ui.button(label="Partenariat", style=discord.ButtonStyle.success, emoji="ü§ù")
        async def partner_button(self, button_interaction: discord.Interaction, button: discord.ui.Button):
            await ticket(button_interaction, "Partenariat")

        @discord.ui.button(label="Autre", style=discord.ButtonStyle.secondary, emoji="üìù")
        async def other_button(self, button_interaction: discord.Interaction, button: discord.ui.Button):
            await ticket(button_interaction, "Autre demande")

    await interaction.response.send_message(embed=embed, view=TicketView())


@bot.event
async def on_ready():
    print(f'Bot connect√© en tant que {bot.user}')
    await bot.tree.sync()


@bot.event
async def on_member_join(member):
    unverified_role = discord.utils.get(member.guild.roles, name="Non v√©rifi√©")
    if not unverified_role:
        unverified_role = await member.guild.create_role(name="Non v√©rifi√©")
    await member.add_roles(unverified_role)
    code = generate_captcha()
    captcha_codes[member.id] = code
    embed = discord.Embed(title="V√©rification requise",
                          color=discord.Color.blue())
    embed.description = f"Bienvenue sur {member.guild.name}!\nPour acc√©der au serveur, utilisez la commande `/verify` avec le code ci-dessous:"
    embed.add_field(name="Votre code de v√©rification", value=f"```{code}```")
    embed.set_footer(text="Utilisez /verify <code> pour vous v√©rifier")
    try:
        await member.send(embed=embed)
        if log_channel:
            await log_channel.send(
                f"ü§ñ Un captcha a √©t√© envoy√© √† {member.mention}")
    except:
        if log_channel:
            await log_channel.send(
                f"‚ùå Impossible d'envoyer le captcha √† {member.mention} (DMs ferm√©s)"
            )


@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # V√©rification des permissions
    if message.author.guild_permissions.administrator:
        return

    # Liste des IDs prot√©g√©s contre le ping
    protected_ids = [
        1026103239227211826, 413445610302078977, 1308157577560985630
    ]

    # Compteur de pings par utilisateur
    if not hasattr(bot, 'ping_counts'):
        bot.ping_counts = {}

    # V√©rification des pings non autoris√©s
    ping_count = sum(1 for id in protected_ids if f"<@{id}>" in message.content)
    if ping_count > 0:
        if message.author.id not in bot.ping_counts:
            bot.ping_counts[message.author.id] = 0
        bot.ping_counts[message.author.id] += ping_count

        if bot.ping_counts[message.author.id] >= 5:
            await message.author.timeout(datetime.timedelta(hours=1), reason="Trop de mentions d'utilisateurs prot√©g√©s")
            await message.channel.send(f"{message.author.mention} a √©t√© mut√© pendant 1 heure pour avoir trop mentionn√© des utilisateurs prot√©g√©s.")
            bot.ping_counts[message.author.id] = 0
            if log_channel:
                await log_channel.send(f"üîá {message.author} a √©t√© mut√© pour avoir mentionn√© des utilisateurs prot√©g√©s trop de fois")
            return

    bucket = spam_cooldown.get_bucket(message)
    retry_after = bucket.update_rate_limit()
    if retry_after:
        await message.delete()
        user_id = message.author.id
        user_spam_count[user_id] = user_spam_count.get(user_id, 0) + 1
        if user_spam_count[user_id] >= 5:
            await message.author.timeout(datetime.timedelta(hours=1),
                                         reason="Spam excessif")
            await message.channel.send(
                f"{message.author.mention} a √©t√© exclu pendant 1 heure pour spam."
            )
            user_spam_count[user_id] = 0
        else:
            await message.channel.send(
                f"{message.author.mention}, merci de ne pas spammer! Avertissement {user_spam_count[user_id]}/5"
            )
        return
    await bot.process_commands(message)


# Commandes de sanctions
def role_check(ctx):
    return any(role.id == staff_role_id for role in ctx.author.roles)


async def check_command_permissions(interaction: discord.Interaction,
                                    command_name: str) -> bool:
    # Seules ces commandes sont accessibles aux membres normaux
    allowed_commands = ["userinfo", "serverinfo", "ticket"]
    if command_name in allowed_commands:
        return True
    # V√©rifie si l'utilisateur a le r√¥le avec l'ID sp√©cifi√©
    allowed_role_id = 1332456096492683364
    if any(role.id == allowed_role_id for role in interaction.user.roles):
        return True
    await interaction.response.send_message(
        "‚ùå Vous n'avez pas la permission d'utiliser cette commande.",
        ephemeral=True)
    return False


@bot.tree.command(name="ban", description="Bannir un utilisateur")
@commands.has_permissions(ban_members=True)
@commands.check(role_check)
async def ban(interaction: discord.Interaction,
              membre: discord.Member,
              raison: str = None):
    if not await check_command_permissions(interaction, "ban"):
        return
    await membre.ban(reason=raison)
    await interaction.response.send_message(
        f"{membre} a √©t√© banni. Raison: {raison}")
    if log_channel:
        await log_channel.send(
            f"üî® {interaction.user} a banni {membre}. Raison: {raison}")


@bot.tree.command(name="kick", description="Expulser un utilisateur")
@commands.has_permissions(kick_members=True)
@commands.check(role_check)
async def kick(interaction: discord.Interaction,
               membre: discord.Member,
               raison: str = None):
    await membre.kick(reason=raison)
    await interaction.response.send_message(
        f"{membre} a √©t√© expuls√©. Raison: {raison}")
    if log_channel:
        await log_channel.send(
            f"üë¢ {interaction.user} a expuls√© {membre}. Raison: {raison}")


@bot.tree.command(name="mute", description="Muter un utilisateur")
@commands.has_permissions(moderate_members=True)
@commands.check(role_check)
async def mute(interaction: discord.Interaction,
               membre: discord.Member,
               duree: int,
               raison: str = None):
    await membre.timeout(datetime.timedelta(minutes=duree), reason=raison)
    await interaction.response.send_message(
        f"{membre} a √©t√© mut√© pour {duree} minutes. Raison: {raison}")
    if log_channel:
        await log_channel.send(
            f"üîá {interaction.user} a mut√© {membre} pour {duree} minutes. Raison: {raison}"
        )


@bot.tree.command(name="unmute", description="D√©muter un utilisateur")
@commands.has_permissions(moderate_members=True)
@commands.check(role_check)
async def unmute(interaction: discord.Interaction, membre: discord.Member):
    await membre.timeout(None)
    await interaction.response.send_message(f"{membre} a √©t√© d√©mut√©.")
    if log_channel:
        await log_channel.send(f"üîä {interaction.user} a d√©mut√© {membre}")


@bot.tree.command(name="warn", description="Avertir un utilisateur")
@commands.has_permissions(moderate_members=True)
@commands.check(role_check)
async def warn(interaction: discord.Interaction, membre: discord.Member,
               raison: str):
    if membre.id not in user_warnings:
        user_warnings[membre.id] = []
    user_warnings[membre.id].append(raison)
    nb_warns = len(user_warnings[membre.id])
    await interaction.response.send_message(
        f"{membre} a re√ßu un avertissement ({nb_warns}/5). Raison: {raison}")
    if nb_warns >= 5:
        await membre.kick(reason="5 avertissements atteints")
        user_warnings[membre.id] = []  # R√©initialiser les avertissements
        await interaction.channel.send(
            f"{membre} a √©t√© expuls√© pour avoir atteint 5 avertissements.")
        if log_channel:
            await log_channel.send(
                f"üë¢ {membre} a √©t√© expuls√© apr√®s 5 avertissements")
    elif log_channel:
        await log_channel.send(
            f"‚ö†Ô∏è {interaction.user} a averti {membre} ({nb_warns}/5). Raison: {raison}"
        )


@bot.tree.command(name="warnings",
                  description="Voir les avertissements d'un utilisateur")
@commands.has_permissions(moderate_members=True)
@commands.check(role_check)
async def warnings(interaction: discord.Interaction, membre: discord.Member):
    if membre.id not in user_warnings or not user_warnings[membre.id]:
        await interaction.response.send_message(
            f"{membre} n'a aucun avertissement.")
        return
    warnings_list = "\n".join([f"- {w}" for w in user_warnings[membre.id]])
    await interaction.response.send_message(
        f"Avertissements de {membre}:\n{warnings_list}")


@bot.tree.command(name="clear", description="Supprimer des messages")
@commands.has_permissions(manage_messages=True)
@commands.check(role_check)
async def clear(interaction: discord.Interaction, nombre: int):
    await interaction.channel.purge(limit=nombre + 1)
    await interaction.response.send_message(
        f"{nombre} messages ont √©t√© supprim√©s")
    if log_channel:
        await log_channel.send(
            f"üóëÔ∏è {interaction.user} a supprim√© {nombre} messages dans {interaction.channel.mention}"
        )


@bot.tree.command(name="slowmode", description="D√©finir le mode lent")
@commands.has_permissions(manage_channels=True)
@commands.check(role_check)
async def slowmode(interaction: discord.Interaction, duree: int):
    await interaction.channel.edit(slowmode_delay=duree)
    await interaction.response.send_message(
        f"Mode lent d√©fini √† {duree} secondes")


@bot.tree.command(name="lock", description="Verrouiller le salon")
@commands.has_permissions(manage_channels=True)
@commands.check(role_check)
async def lock(interaction: discord.Interaction):
    if isinstance(interaction.channel, discord.VoiceChannel):
        await interaction.channel.set_permissions(interaction.guild.default_role,
                                                connect=False,
                                                speak=False)
    else:
        await interaction.channel.set_permissions(interaction.guild.default_role,
                                                send_messages=False,
                                                add_reactions=False)
    await interaction.response.send_message("üîí Salon verrouill√©")
    if log_channel:
        await log_channel.send(
            f"üîí {interaction.user} a verrouill√© {interaction.channel.mention}")


@bot.tree.command(name="unlock", description="D√©verrouiller le salon")
async def unlock(interaction: discord.Interaction):
    if not await check_command_permissions(interaction, "unlock"):
        return
    try:
        if isinstance(interaction.channel, discord.VoiceChannel):
            await interaction.channel.set_permissions(interaction.guild.default_role,
                                                    connect=True,
                                                    speak=True)
        else:
            await interaction.channel.set_permissions(interaction.guild.default_role,
                                                    send_messages=True,
                                                    add_reactions=True)
        await interaction.response.send_message("üîì Salon d√©verrouill√©")
        if log_channel:
            await log_channel.send(
                f"üîì {interaction.user} a d√©verrouill√© {interaction.channel.mention}")
    except discord.Forbidden:
        await interaction.response.send_message("Je n'ai pas la permission de d√©verrouiller ce salon.", ephemeral=True)



# Commandes d'information
@bot.tree.command(name="userinfo",
                  description="Informations sur un utilisateur")
async def userinfo(interaction: discord.Interaction, membre: discord.Member):
    embed = discord.Embed(title=f"Informations sur {membre}")
    embed.add_field(name="ID", value=membre.id)
    embed.add_field(name="Rejoint le",
                    value=membre.joined_at.strftime("%d/%m/%Y"))
    embed.add_field(name="Compte cr√©√© le",
                    value=membre.created_at.strftime("%d/%m/%Y"))
    embed.add_field(name="R√¥les",
                    value=", ".join([r.name for r in membre.roles[1:]]))
    await interaction.response.send_message(embed=embed)


@bot.tree.command(name="serverinfo", description="Informations sur le serveur")
async def serverinfo(interaction: discord.Interaction):
    guild = interaction.guild
    embed = discord.Embed(title=f"Informations sur {guild.name}")
    embed.add_field(name="Membres", value=guild.member_count)
    embed.add_field(name="Cr√©√© le",
                    value=guild.created_at.strftime("%d/%m/%Y"))
    embed.add_field(name="Nombre de r√¥les", value=len(guild.roles))
    await interaction.response.send_message(embed=embed)


# Commandes de gestion des r√¥les
@bot.tree.command(name="addrole", description="Ajouter un r√¥le")
@commands.has_permissions(manage_roles=True)
@commands.check(role_check)
async def addrole(interaction: discord.Interaction, membre: discord.Member,
                  role: discord.Role):
    await membre.add_roles(role)
    await interaction.response.send_message(
        f"Le r√¥le {role.name} a √©t√© ajout√© √† {membre}")
    if log_channel:
        await log_channel.send(
            f"‚ûï {interaction.user} a ajout√© le r√¥le {role.name} √† {membre}")


@bot.tree.command(name="removerole", description="Retirer un r√¥le")
@commands.has_permissions(manage_roles=True)
@commands.check(role_check)
async def removerole(interaction: discord.Interaction, membre: discord.Member,
                     role: discord.Role):
    await membre.remove_roles(role)
    await interaction.response.send_message(
        f"Le r√¥le {role.name} a √©t√© retir√© √† {membre}")
    if log_channel:
        await log_channel.send(
            f"‚ûñ {interaction.user} a retir√© le r√¥le {role.name} √† {membre}")


# Commandes Anti-Raid
@bot.tree.command(name="antiraid",
                  description="Activer/d√©sactiver l'anti-raid")
@commands.has_permissions(administrator=True)
async def antiraid(interaction: discord.Interaction, etat: bool):
    global antiraid_enabled
    antiraid_enabled = etat
    await interaction.response.send_message(
        f"Anti-raid {'activ√©' if etat else 'd√©sactiv√©'}")
    if log_channel:
        await log_channel.send(
            f"üõ°Ô∏è {interaction.user} a {'activ√©' if etat else 'd√©sactiv√©'} l'anti-raid"
        )


@bot.tree.command(name="whitelist", description="G√©rer la whitelist")
@commands.has_permissions(administrator=True)
async def whitelist_cmd(interaction: discord.Interaction, action: str,
                        membre: discord.Member):
    if action == "add":
        whitelist.add(membre.id)
        await interaction.response.send_message(
            f"{membre} a √©t√© ajout√© √† la whitelist")
    elif action == "remove":
        whitelist.remove(membre.id)
        await interaction.response.send_message(
            f"{membre} a √©t√© retir√© de la whitelist")


# Configuration des logs
@bot.tree.command(name="logchannel", description="D√©finir le salon des logs")
@commands.has_permissions(administrator=True)
async def set_log_channel(interaction: discord.Interaction,
                          channel: discord.TextChannel):
    global log_channel
    log_channel = channel
    await interaction.response.send_message(
        f"Salon des logs d√©fini sur {channel.mention}")


@bot.tree.command(name="nouveau_code",
                  description="Recevoir un nouveau code de v√©rification")
async def nouveau_code(interaction: discord.Interaction):
    code = generate_captcha()
    captcha_codes[interaction.user.id] = code
    embed = discord.Embed(title="Nouveau code de v√©rification",
                          color=discord.Color.blue())
    embed.description = f"Voici votre nouveau code de v√©rification. Utilisez la commande `/verify` avec le code ci-dessous:"
    embed.add_field(name="Votre nouveau code", value=f"```{code}```")
    embed.set_footer(text="Utilisez /verify <code> pour vous v√©rifier")
    try:
        await interaction.user.send(embed=embed)
        await interaction.response.send_message(
            "Un nouveau code vous a √©t√© envoy√© en message priv√©.",
            ephemeral=True)
        if log_channel:
            await log_channel.send(
                f"üîÑ Un nouveau code captcha a √©t√© envoy√© √† {interaction.user.mention}"
            )
    except:
        await interaction.response.send_message(
            "Impossible de vous envoyer un message priv√©. Veuillez activer vos DMs.",
            ephemeral=True)
        if log_channel:
            await log_channel.send(
                f"‚ùå Impossible d'envoyer le nouveau captcha √† {interaction.user.mention} (DMs ferm√©s)"
            )


# Lancer le bot
bot.run(os.getenv('DISCORD_TOKEN'))
